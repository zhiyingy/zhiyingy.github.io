<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="zhiyingy.GitHub.io : 15418 Final Project">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>zhiyingy.GitHub.io</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/zhiyingy">View on GitHub</a>

          <h1 id="project_title">Simulating Locks implementation</h1>
          <h2 id="project_tagline">Zhiying Yao (zhiyingy)</h2>
          <h2 id="project_tagline"> Hongyi Ding (hongyid) </h2>
          

        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a href="final.html"><h3><font color="blue"> Click here for the Final Writeup </font></h2></a>
<a href="schedule.html"><h3><font color="blue"> Click here for the Project Schedule </font></h3></a>


<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true"><span class="octicon octicon-link"></span></a>Summary</h3>

<p>
For this project, we will implement different types of locks to test the performance of various synchronization primitives. Specifically, we will be implementing test-and-set lock, test-and-test-and-set lock, ticket locks and queue-based locks. If time permitted, we will implement a lock free AVL tree and compare the performance.
</p>



<h3>
<a id="designer-templates" class="anchor" href="#designer-templates" aria-hidden="true"><span class="octicon octicon-link"></span></a>Background</h3>

<p>
Synchronization is an important topic in parallelism to ensure the correctness of the program. 
  In class, we learned about different implementations of synchronization such as locks and lock free data structures.
  Here, we want to compare the performance of different lock implementations and a lock free data structure. We chose AVL tree here because self-balancing binary search trees are an important data structure that are used in many algorithms.

</p>

<h3>
<a id="rather-drive-stick" class="anchor" href="#rather-drive-stick" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Challenge</h3>

<p>

The challenging part will be to correctly implement a cache emulator that accepts the memory traces produced by Pin, and then models the program's actions by adhering to whichever protocol the user selects. As the simulator itself will be a serial program, we will not have problems such as race conditions, poor work distribution, or divergent execution. 
<br>

For the emulator, not only will it be difficult to design and create a system that handles the memory traces for the different protocols to interpret, but implementing the protocols themselves will be difficult to do in an exact manner, as well as tracking key performance parameters while simulating the cache.

</p>

<h3>
<a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Resources</h3>

<p>
We will be using Intel Pin tool to generate the memory traces of parallel programs. We will refer to lecture slides for the details about the MSI and MESI protocols, as well as for any other additional information needed. We will also be using the paper by <a href="https://dl.acm.org/citation.cfm?id=6514">Archibald and Baer</a> for specification of the Dragon protocol. We will program our simulator using C++, and will use either our own computers or any Gates machines. 
</p>

<h3>
<a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true"><span class="octicon octicon-link"></span></a>Goals and Deliverables</h3>

<p>
<h3> Plan to achieve</h3>
<ul>
<li>
Create a cache simulator that successfully takes in a memory trace generated by Pin and simulates how the caches would act according to the MSI, MESI, and MOESI protocols.
</li>
<li>
  Generate statistics regarding cache misses, cache hits, and communication overhead. Plot with respect to traced application and which protocol used. 
</li>
</ul>
<h3> Hope to achieve
</h3>
<ul>
  <li>
    Implement the dragon protocol.
  </li>
  <li>
    Implement a directory-based cache coherence protocol.
  </li>
  <li>
    Create a graphical application of our own, measure its performance, and then run it in our simulator to determine which cache protocol gives the best performance.
  </li>
</ul>
The demo we would show at the competition would be of the graphs showing the difference between the different protocols, and how those differences vary with respect to what program is ran.
</p>
<h3><a id="platform choice" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Platform Choice</h3>
<p>
  We will use C++ to write our simulator, as this will enable us to roughly model how the simulation translates to hardware, while providing us the ability to use classes for better organization. 
</p>


<h3><a id="schedule" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Initial Schedule</h3>
<ul>
  <li>
    By April 9th: Understand how to use Intel Pin. Break the simulator into components and map out their interactions in a generalized fashion.
  </li>
  <li>
    By April 16th: Have the ability to Pin a program and parse the resulting data. Begin implementing the MSI protocol to the point it can accept the Pin trace data.
  </li>
  <li>
    By April 23rd: Finish the MSI protocol. 
  </li>
  <li>
    By April 30th: Finish the MESI, work on the MOESI protocol, and begin implementing the Dragon Protocol.
  </li>
  <li>
    By May 7th: Finish the MOESI and Dragon Protocols. Generate the graphs showing the differences in performance for the different protocols.
  </li>

</ul>


      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
